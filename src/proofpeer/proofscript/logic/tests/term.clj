(ns proofpeer.proofscript.logic.tests.term
  (:use clojure.test)
  (:use proofpeer.proofscript.logic.term)
  (:use proofpeer.proofscript.logic.term-utils))

(deftest term-tests
  (let [x-ty      (mk-tyvar         :'x)
        int       (mk-tyconstructor :int)
        list      (mk-tyconstructor :list x-ty)
        length-ty (nary             list int)
        add-ty    (nary             int int int)
        length    (mk-const         'length length-ty)
        add       (mk-const         'add    add-ty)
        x-var     (mk-var           'x      x-ty)
        int-var   (mk-var           'n      int)
        zero      (mk-const         0       int)
        one       (mk-const         1       int)
        two       (mk-const         2       int)  
        suc       (mk-abs           int-var (mk-binop add int-var one))
        three     (mk-comb          suc     two)
        six       (mk-binop         add     three three)]
    (do
      (is (= (dest-var   x-var)   'x))
      (is (= (dest-var   zero)     nil))
      (is (= (dest-var   three)    nil))
      (is (= (dest-var   suc)      nil))
      (is (= (dest-const x-var)    nil))
      (is (= (dest-const zero)     0))  
      (is (= (dest-const three)    nil))
      (is (= (dest-const suc)      nil))
      (is (= (dest-comb  x-var)    nil))
      (is (= (dest-comb  zero)     nil))  
      (is (= (dest-comb  three)    [suc two]))
      (is (= (dest-comb  suc)      nil))
      (is (= (dest-abs   x-var)    nil))
      (is (= (dest-abs   zero)     nil))
      (is (= (dest-abs   three)    nil))
      (is (= (dest-abs   suc)      [int-var (mk-binop add int-var one)]))

      (is (= (type-of    add)               (nary int int int)))
      (is (= (type-of    one)               int))
      (is (= (type-of    suc)               (nary int int)))
      (is (= (type-of    three)             int))
      (is (= (type-of    (mk-comb suc suc)) nil)))))
